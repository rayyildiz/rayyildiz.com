<!doctype html><html lang=en><head><title>Async pattern in Rust and CSP · Ramazan AYYILDIZ</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ramazan AYYILDIZ"><meta name=description content="Asynchronous programming in Rust has sparked considerable debate within the programming community. On one side, advocates argue that async enhances performance and scalability, especially in I/O-bound and high-concurrency applications. On the other side, critics point to its complexity and potential for complicating the codebase. To fully understand this debate, it&rsquo;s crucial to examine the differences between asynchronous programming and the Communicating Sequential Processes (CSP) model, particularly as implemented through channels in Rust."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rayyildiz.com/avatars/rayyildiz.jpg"><meta name=twitter:title content="Async pattern in Rust and CSP"><meta name=twitter:description content="Asynchronous programming in Rust has sparked considerable debate within the programming community. On one side, advocates argue that async enhances performance and scalability, especially in I/O-bound and high-concurrency applications. On the other side, critics point to its complexity and potential for complicating the codebase. To fully understand this debate, it’s crucial to examine the differences between asynchronous programming and the Communicating Sequential Processes (CSP) model, particularly as implemented through channels in Rust."><meta property="og:url" content="https://rayyildiz.com/posts/async-in-rust-vs-csp/"><meta property="og:site_name" content="Ramazan AYYILDIZ"><meta property="og:title" content="Async pattern in Rust and CSP"><meta property="og:description" content="Asynchronous programming in Rust has sparked considerable debate within the programming community. On one side, advocates argue that async enhances performance and scalability, especially in I/O-bound and high-concurrency applications. On the other side, critics point to its complexity and potential for complicating the codebase. To fully understand this debate, it’s crucial to examine the differences between asynchronous programming and the Communicating Sequential Processes (CSP) model, particularly as implemented through channels in Rust."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-15T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="og:image" content="https://rayyildiz.com/avatars/rayyildiz.jpg"><meta property="og:see_also" content="https://rayyildiz.com/posts/android-uses-rust-for-memory-safety/"><meta property="og:see_also" content="https://rayyildiz.com/posts/introduction-to-rust-language/"><meta property="og:see_also" content="https://rayyildiz.com/posts/rust-vs-go/"><link rel=canonical href=https://rayyildiz.com/posts/async-in-rust-vs-csp/><link rel=preload href=https://rayyildiz.com/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://rayyildiz.com/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://rayyildiz.com/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://rayyildiz.com/css/coder.min.6445a802b9389c9660e1b07b724dcf5718b1065ed2d71b4eeaf981cc7cc5fc46.css integrity="sha256-ZEWoArk4nJZg4bB7ck3PVxixBl7S1xtO6vmBzHzF/EY=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://rayyildiz.com/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=https://rayyildiz.com/images/favicon.svg sizes=any><link rel=icon type=image/png href=https://rayyildiz.com/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://rayyildiz.com/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=https://rayyildiz.com/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://rayyildiz.com/images/apple-touch-icon.png><link rel=manifest href=https://rayyildiz.com/site.webmanifest><link rel=mask-icon href=https://rayyildiz.com/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://rayyildiz.com/>Ramazan AYYILDIZ
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=https://rayyildiz.com/tr/>Türkçe</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://rayyildiz.com/posts/async-in-rust-vs-csp/>Async pattern in Rust and CSP</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2024-01-15T00:00:00Z>January 15, 2024
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
4-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=https://rayyildiz.com/categories/programming/>Programming</a></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=https://rayyildiz.com/tags/rust/>Rust</a></span></div></div></header><div class=post-content><p>Asynchronous programming in Rust has sparked considerable debate within the programming community. On one side, advocates argue that async enhances performance and scalability, especially in I/O-bound and high-concurrency applications. On the other side, critics point to its complexity and potential for complicating the codebase. To fully understand this debate, it&rsquo;s crucial to examine the differences between asynchronous programming and the <a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes class=external-link target=_blank rel=noopener>Communicating Sequential Processes</a> (CSP) model, particularly as implemented through channels in Rust.</p><h2 id=understanding-asynchronous-programming>Understanding Asynchronous Programming
<a class=heading-link href=#understanding-asynchronous-programming><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Asynchronous programming allows a program to initiate a potentially long-running task and move on to other tasks without waiting for the first one to complete. This is particularly useful in networked applications, where I/O operations can introduce significant delays. In Rust, the <code>async</code> keyword marks asynchronous functions, which return a <a href=https://doc.rust-lang.org/std/future/trait.Future.html class=external-link target=_blank rel=noopener>Future</a>. This Future represents a value that may become available at some point. The Rust runtime, through an executor, is responsible for polling these <code>Futures</code> and driving them to completion.</p><h3 id=example>Example
<a class=heading-link href=#example><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Rust&rsquo;s standard library provides the foundational traits and types for async programming but does not include a runtime to execute <code>Futures</code>. To run async code, you indeed need to use an external crate that provides an async runtime, such as <a href=https://tokio.rs class=external-link target=_blank rel=noopener>tokio</a>, <a href=https://async.rs class=external-link target=_blank rel=noopener>async-std</a>, or <a href=https://github.com/smol-rs/smol class=external-link target=_blank rel=noopener>smol</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>fetch_data</span>(url: <span style=color:#ff79c6>&amp;</span><span style=color:#8be9fd>str</span>) -&gt; <span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd;font-style:italic>String</span>, <span style=color:#ff79c6>&amp;</span><span style=color:#8be9fd;font-style:italic>&#39;static</span> <span style=color:#8be9fd>str</span><span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>println!</span>(<span style=color:#f1fa8c>&#34;Fetching data from: </span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>&#34;</span>, url);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// business logic
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Ok</span>(<span style=color:#8be9fd;font-style:italic>String</span>::from(<span style=color:#f1fa8c>r</span><span style=color:#f1fa8c>#&#34;{&#34;name&#34;:&#34;rayyildiz&#34;,&#34;bio&#34;:&#34;just for fun&#34;}&#34;#</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>match</span> fetch_data(<span style=color:#f1fa8c>&#34;https://api.rayyildiz.com&#34;</span>).<span style=color:#ff79c6>await</span> {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>Ok</span>(data) <span style=color:#ff79c6>=&gt;</span> <span style=color:#50fa7b>println!</span>(<span style=color:#f1fa8c>&#34;Received data: </span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>&#34;</span>, data),
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>Err</span>(e) <span style=color:#ff79c6>=&gt;</span> <span style=color:#50fa7b>println!</span>(<span style=color:#f1fa8c>&#34;An error occurred: </span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>&#34;</span>, e),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You need to add tokio in your <strong>Cargo.toml</strong> to run this example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[dependencies]
</span></span><span style=display:flex><span>tokio = { version = <span style=color:#f1fa8c>&#34;1.0&#34;</span>, features = [<span style=color:#f1fa8c>&#34;full&#34;</span>] }
</span></span></code></pre></div><h3 id=pros-of-async-in-rust>Pros of Async in Rust:
<a class=heading-link href=#pros-of-async-in-rust><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><strong>Non-blocking I/O:</strong> Async allows for non-blocking I/O operations, enabling the handling of thousands of connections simultaneously without the overhead of threads.</p><p><strong>Improved Performance:</strong> By avoiding unnecessary waits, async can significantly improve the performance of I/O-bound applications.</p><p><strong>Resource Efficiency:</strong> Async reduces the need for threads, which are more expensive in terms of system resources.</p><h3 id=cons-of-async-in-rust>Cons of Async in Rust:
<a class=heading-link href=#cons-of-async-in-rust><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><strong>Learning Curve:</strong> The async/await syntax and the concept of futures can be challenging for newcomers.</p><p><strong>Complexity:</strong> Error handling, lifetime management, and task coordination can introduce complexity, making code harder to understand and maintain.</p><p><strong>Compatibility:</strong> Not all libraries are async-aware, potentially leading to blocking calls that can negate the benefits of async programming.</p><h2 id=channels-in-rust>Channels in Rust
<a class=heading-link href=#channels-in-rust><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The CSP model, on the other hand, involves concurrent processes communicating through channels, without sharing memory. In Rust, this is implemented using the <a href=https://doc.rust-lang.org/std/sync/mpsc/index.html class=external-link target=_blank rel=noopener>std::sync::mpsc</a> (multi-producer, single-consumer) for synchronous communication, and <a href=https://docs.rs/tokio/latest/tokio/sync/mpsc/index.html class=external-link target=_blank rel=noopener>tokio::sync::mpsc</a> for asynchronous communication.</p><h3 id=example-1>Example
<a class=heading-link href=#example-1><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Rust code snippet demonstrates a simple yet powerful use of Rust&rsquo;s concurrency primitives, specifically using the <code>std::sync::mpsc</code> (multi-producer, single-consumer) channel for communication between threads. The program then prints the total sum of all numbers received from the spawned thread, which, in this case, is the sum of the first 10,000,000 positive integers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> std::sync::mpsc;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> std::thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> (tx, rx) <span style=color:#ff79c6>=</span> mpsc::channel();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    thread::spawn(<span style=color:#ff79c6>move</span> <span style=color:#ff79c6>||</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>1</span><span style=color:#ff79c6>..</span><span style=color:#bd93f9>10_000_001</span> {
</span></span><span style=display:flex><span>            tx.send(i <span style=color:#ff79c6>as</span> <span style=color:#8be9fd>u64</span>).unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> <span style=color:#ff79c6>mut</span> sum <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> a <span style=color:#ff79c6>in</span> rx {
</span></span><span style=display:flex><span>        sum <span style=color:#ff79c6>+=</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>println!</span>(<span style=color:#f1fa8c>&#34;sum :</span><span style=color:#f1fa8c>{}</span><span style=color:#f1fa8c>&#34;</span>, sum);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=pros-of-csp-in-rust>Pros of CSP in Rust:
<a class=heading-link href=#pros-of-csp-in-rust><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><strong>Simplicity:</strong> CSP can be easier to reason about, as each process has its own state and communicates through well-defined channels.</p><p><strong>Safety:</strong> Rust&rsquo;s type system and ownership model ensure safe concurrent access to resources without data races.</p><p><strong>Flexibility:</strong> Channels can be used in both synchronous and asynchronous contexts, making them versatile for different concurrency models.</p><h3 id=cons-of-csp-in-rust>Cons of CSP in Rust:
<a class=heading-link href=#cons-of-csp-in-rust><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><strong>Overhead:</strong> The creation and management of channels and messages can introduce overhead, especially if not used judiciously.</p><p><strong>Limited Scalability:</strong> For some highly concurrent applications, the overhead of message passing can become a bottleneck compared to non-blocking async operations.</p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Ultimately, both async and CSP have their place in Rust&rsquo;s concurrency model. The &ldquo;good or bad&rdquo; debate around async in Rust isn&rsquo;t about dismissing one approach in favor of the other; it&rsquo;s about understanding the trade-offs and making informed decisions based on your application&rsquo;s needs. By leveraging Rust&rsquo;s powerful type system and concurrency features, developers can build efficient, safe, and scalable applications, whether they choose async, CSP, or a combination of both.</p><ul><li><p>Use <strong>async</strong> for high-concurrency, I/O-bound applications where non-blocking I/O and resource efficiency are critical.</p></li><li><p>Consider <strong>CSP</strong> for applications where the logic naturally fits into distinct processes communicating through channels, and where the overhead of channels is justified by the benefits of easier reasoning and code safety.</p></li></ul></div><footer><section class=see-also></section></footer></article></section></div><footer class=footer><section class=container>©
2025
Ramazan AYYILDIZ</section></footer></main><script src=https://rayyildiz.com/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "012efc48b40e46dab7acdc375ba96820"}'></script></body></html>